-- generated sp 184: tier=large flags=[noformatting,deeptrycatch,nocaps]
-- expect  sources:[stg].[customerstage],[dbo].[transaction],[rpt].[salessummary],[hr].[employee],[ops].[returnorder],[dbo].[employee]  targets:[rpt].[employeeperf],[audit].[changelog],[fin].[transaction]  exec:[dbo].[usp_applydiscount],[dbo].[usp_archiveorders],[fin].[usp_postjournal]

create procedure [rpt].[usp_genlarge_184] @batchid    int = 0, @processdate datetime = null as begin set nocount on; if @processdate is null set @processdate = getdate(); declare @rowcount int = 0; declare @starttime datetime = getutcdate(); begin try begin try insert into [rpt].[employeeperf] ([sourceid], [sourcename], [loadedat]) select s.[id], s.[name], getutcdate() from   stg.customerstage as s where  s.[isdeleted] = 0; end try begin catch set @errormessage = error_message(); set @errorseverity = error_severity(); set @errorstate = error_state(); raiserror(@errormessage, @errorseverity, @errorstate); end catch end try begin catch set @errormessage = error_message(); set @errorseverity = error_severity(); set @errorstate = error_state(); raiserror(@errormessage, @errorseverity, @errorstate); end catch set @rowcount = @rowcount + @@rowcount; begin try begin try insert into audit.changelog ([sourceid], [refid], [amount], [loadedat]) select a.[id]          as sourceid, b.[id]          as refid, isnull(a.[amount], 0) as amount, getutcdate()    as loadedat from   [stg].[customerstage] as a join   dbo.transaction as c on c.[id] = a.[id] join   rpt.salessummary as d on d.[id] = a.[id] where  a.[status] = n'pending'; end try begin catch set @errormessage = error_message(); set @errorseverity = error_severity(); set @errorstate = error_state(); raiserror(@errormessage, @errorseverity, @errorstate); end catch end try begin catch set @errormessage = error_message(); set @errorseverity = error_severity(); set @errorstate = error_state(); raiserror(@errormessage, @errorseverity, @errorstate); end catch set @rowcount = @rowcount + @@rowcount; begin try begin try insert into [fin].[transaction] ([sourceid], [refid], [amount], [loadedat]) select a.[id]          as sourceid, b.[id]          as refid, isnull(a.[amount], 0) as amount, getutcdate()    as loadedat from   stg.customerstage as a join   dbo.transaction as c on c.[id] = a.[id] join   [rpt].[salessummary] as d on d.[id] = a.[id] where  a.[status] = n'pending'; end try begin catch set @errormessage = error_message(); set @errorseverity = error_severity(); set @errorstate = error_state(); raiserror(@errormessage, @errorseverity, @errorstate); end catch end try begin catch set @errormessage = error_message(); set @errorseverity = error_severity(); set @errorstate = error_state(); raiserror(@errormessage, @errorseverity, @errorstate); end catch set @rowcount = @rowcount + @@rowcount; update t set    t.[status]      = s.[status], t.[updateddate] = getutcdate() from   [rpt].[employeeperf] as t join   [dbo].[transaction] as s on s.[id] = t.[sourceid] where  t.[status] = n'pending'; set @rowcount = @rowcount + @@rowcount; merge into [fin].[transaction] as tgt using dbo.employee as src on src.[id] = tgt.[id] when matched then update set tgt.[name] = src.[name], tgt.[updateddate] = getutcdate() when not matched by target then insert ([id], [name], [createddate]) values (src.[id], src.[name], getutcdate()) when not matched by source then update set tgt.[isdeleted] = 1; exec dbo.usp_applydiscount @processdate = getdate(), @batchid = @batchid; exec [dbo].[usp_archiveorders] @processdate = getdate(), @batchid = @batchid; exec fin.usp_postjournal @processdate = getdate(), @batchid = @batchid; select @rowcount = count(*) from stg.customerstage where [isdeleted] = 0; select @rowcount = count(*) from [dbo].[transaction] where [isdeleted] = 0; select @rowcount = count(*) from rpt.salessummary where [isdeleted] = 0; select @rowcount = count(*) from hr.employee where [isdeleted] = 0; select @rowcount = count(*) from [ops].[returnorder] where [isdeleted] = 0; select @rowcount = count(*) from [dbo].[employee] where [isdeleted] = 0; return @rowcount; end go